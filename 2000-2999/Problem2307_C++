#include <iostream>
#include <math.h>

using namespace std;

#define WHITE -1

//  Function, that teturn lowest power of 2, bigger than a given number
int lowestBiggerPowOf2Than(int number) {
	int answer;
	answer = 1 << (int)(log2(number - 1.0) + 1);
	return answer;
}

//  The structure describing the components from which consists a tree
struct Node {
	int color;
	long long sumOnSegment;
	//  The default constructor
	Node() {
		color = WHITE;
		sumOnSegment = 0;
	}
	//  Construct the node by its color and sum on corresponding segment
	Node(int color, long long sumOnSegment) {
		this->color = color;
		this->sumOnSegment = sumOnSegment;
	}
	//  Define, if this node is painted in some color (some number is assigned)
	bool isColored() { return color != WHITE; }
};

//  Function, that pushes information from parent to the children
void push(Node *tree, int currentNode, int left, int right) {
	if (tree[currentNode].isColored()) {
		int middle = (left + right) / 2;
		int leftChild = 2 * currentNode;
		//  Pass color from parent to children
		tree[leftChild].color = tree[currentNode].color;
		tree[leftChild + 1].color = tree[currentNode].color;
		//  Execute recalculation of the amount in the corresponding segments at children
		tree[leftChild].sumOnSegment = (long long)(middle - left + 1) * tree[leftChild].color;
		tree[leftChild + 1].sumOnSegment = (long long)(right - middle) * tree[leftChild + 1].color;
		//  Note parent's node as uncolored
		tree[currentNode].color = WHITE;
	}
}

//  Function, that updates the value of all nodes on a segment for the specified 
void update(Node *tree, int currentNode, int left, int right, int leftBorder, int rightBorder, int color) {
	if (leftBorder == left && rightBorder == right) {
		tree[currentNode] = Node(color, (long long)(right - left + 1) * color);
	}
	else {
		//  Executes the delayed update (pushes information)
		push(tree, currentNode, left, right);
		int leftChild = 2 * currentNode;
		int middle = (left + right) / 2;
		if (rightBorder <= middle) {
			update(tree, leftChild, left, middle, leftBorder, rightBorder, color);
		}
		else if (leftBorder >= middle + 1) update(tree, leftChild + 1, middle + 1, right, leftBorder, rightBorder, color);
		else {
			update(tree, leftChild, left, middle, leftBorder, middle, color);
			update(tree, leftChild + 1, middle + 1, right, middle + 1, rightBorder, color);
		}
		//  Update the amount in corresponding to parent segment
		tree[currentNode].sumOnSegment = tree[leftChild].sumOnSegment + tree[leftChild + 1].sumOnSegment;
	}
}

//  Function, that calculates the sum at a specified segment
long long sum(Node *tree, int currentNode, int left, int right, int leftBorder, int rightBorder) {
	if (left == leftBorder && right == rightBorder) {
		return tree[currentNode].sumOnSegment;
	}
	//  Executes the delayed update (pushes information)
	push(tree, currentNode, left, right);
	int leftChild = 2 * currentNode;
	int middle = (left + right) / 2;
	if (rightBorder <= middle) return sum(tree, leftChild, left, middle, leftBorder, rightBorder);
	if (leftBorder >= middle + 1) return sum(tree, leftChild + 1, middle + 1, right, leftBorder, rightBorder);
	return sum(tree, leftChild, left, middle, leftBorder, middle) + sum(tree, leftChild + 1, middle + 1, right, middle + 1, rightBorder);
}

int main() {
	unsigned int quantityOfNumbers;
	cin >> quantityOfNumbers;
	unsigned int sizeOfTree = 2 * lowestBiggerPowOf2Than(quantityOfNumbers);
	Node *tree = new Node[sizeOfTree];
	unsigned int quantityOfRequests;
	cin >> quantityOfRequests;
	for (unsigned int indexOfRequest = 0; indexOfRequest < quantityOfRequests; indexOfRequest++) {
		char request;
		cin >> request;
		unsigned int leftBorder, rightBorder;
		if (request == 'A') {
			int value;
			cin >> leftBorder >> rightBorder >> value;
			update(tree, 1, 0, quantityOfNumbers - 1, leftBorder - 1, rightBorder - 1, value);
		}
		else if (request == 'Q') {
			cin >> leftBorder >> rightBorder;
			cout << sum(tree, 1, 0, quantityOfNumbers - 1, leftBorder - 1, rightBorder - 1) << endl;
		}
	}
	return 0;
}
