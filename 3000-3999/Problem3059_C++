#include <algorithm>

using namespace std;

struct node
{
	int l, r, minn;
} tree[200010];

void build(int o, int l, int r)
{
	tree[o].l = l, tree[o].r = r, tree[o].minn = 1e9;
	if (l == r) return;
	int mi = (l + r) / 2;
	build(o << 1, l, mi);
	build(o << 1 | 1, mi + 1, r);
}

int query(int o, int l, int r)
{
	if (tree[o].l == l && tree[o].r == r) return tree[o].minn;
	int mi = (tree[o].l + tree[o].r) / 2;
	if (r <= mi) return query(o << 1, l, r);
	if (l > mi) return query(o << 1 | 1, l, r);
	return min(query(o << 1, l, mi), query(o << 1 | 1, mi + 1, r));
}

void update(int o, int pos, int val)
{
	if (tree[o].l == tree[o].r)
	{
		tree[o].minn = min(tree[o].minn, val);
		return;
	}
	int mi = (tree[o].l + tree[o].r) / 2;
	if (pos <= mi) update(o << 1, pos, val);
	else update(o << 1 | 1, pos, val);
	tree[o].minn = min(tree[o << 1].minn, tree[o << 1 | 1].minn);
}

int main()
{
	int n, m, i, k, l, r, dp[50010];
	scanf("%d%d", &n, &m);
	for (i = 2; i <= n; i++) dp[i] = 1e9;
	build(1, 1, n);
	update(1, 1, 0);
	for (i = 1; i <= m; i++)
	{
		scanf("%d%d", &l, &r);
		k = query(1, l, r) + 1;
		if (dp[r] > k)
		{
			dp[r] = k;
			update(1, r, k);
		}
	}
	printf("%d\n", dp[n]);
	return 0;
}
